# 선택 정렬

- 해당 회차에 원소를 넣을 위치는 정해져있고, 그 원소를 선택하는 정렬

  - 첫 번째 회차에선 첫번째 위치에 최솟값이 되는 원소을 넣는다.
 
  - 두 번째 회차에선 두번째 위치에 남은 값 중 최솟값이 되는 원소를 넣는다.


## 과정

<https://www.youtube.com/watch?v=yXE9kFLHSOs>

  1. 
  
  - 첫 번째 자리에 위치한 원소가 '최솟값'이 된다.
 
  - 맨 앞에 위치한 원소와 나머지 원소를 하나씩 비교하면서, 더 작은 수가 나올 때마다 해당 숫자가 '최솟값'이 된다.
    
  - 1회차의 최종 '최솟값'을 찾으면 첫 번째 원소와 최솟값을 교체한다

 2.
   
   - 첫 번째 자리 원소는 제외되고, 이번에는 두 번째 자리에 위치한 원소가 '최솟값'이 된다.

   - 두 번째 자리에 위치한 원소와 나머지 원소를 하나씩 비교하면서, 더 작은 수가 나올 때마다 해당 숫자가 '최솟값'이 된다.

   - 2회차의 최종 '최솟값'을 찾으면 두 번째 원소와 최솟값을 교체한다.
   
  *반복*

## 장단점

**장점**

- 자료 이동 횟수가 미리 결정된다.

**단점**

- 값이 동일한 요소끼리 비교할 땐, 상대적인 순서가 바뀔 수 있다.

  -> ***불안정하다***
  
  -> **값이 같은 요소가 중요하거나 기존 순서가 보존돼야 하는 경우, 적합하지 않다**


 
    ![선택정렬](https://gmlwjd9405.github.io/images/algorithm-selection-sort/selection-sort.png)

 ## 시간 복잡도

 **비교 횟수**

- 외부 루프의 각 단계마다 i번의 비교 수행

- 외부 루프: n-1 번

- 내부 루프(최솟값 찾기): n-1, n-2, n-3, ..., 2, 1 번

  **교환 횟수**

  - 외부 루프의 교환 횟수와 동일
 
  - 한번 교환하기 위해 3번의 이동(SWAP)이 필요하기 때문에 3(n-1)번
 
    ```python
    temp = a
    a = b
    b = temp
    ```
    
T(n) = (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 = O(n^2)

![시간복잡도 비교](https://gmlwjd9405.github.io/images/algorithm-selection-sort/sort-time-complexity.png)

단순하지만 비효율적:

  선택정렬, 삽입정렬, 버블정렬

복잡하지만 효율적:

  퀵정렬, 힙정렬, 병합정렬
  
----------------

# 삽입 정렬

<https://www.youtube.com/watch?v=fIe7gdgMvMU>

- 자료 배열의 모든 요소를 **앞에서부터 차례대로 이미 정렬된 배열 부분과 비교**하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘

- 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 넣는다.

- **두 번째 자료부터 시작**하여 그 앞의 자료들(왼쪽)과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘

-  즉, 2번째 자료는 1, 2번째 자료, 3번째 자료는 1, 2, 3번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다.
    자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.

   ![삽입 정렬](https://gmlwjd9405.github.io/images/algorithm-insertion-sort/insertion-sort.png)


## 장단점

**장점**

   - 안정적
 
   - 레코드 수가 적을 경우, 또는 이미 대부분 정렬되어 있는 경우 매우 효율적일 수 있음
 
**단점**

   - 비교적 많은 요소가 이동한다.

   - 요소 수가 많을 경우, 적합하지 않다.

## 시간 복잡도

**최선의 경우**

  비교 횟수
    
    - 이동 없이 1번의 비교만 이루어짐

    - 외부 루프: n-1 번

  **Best T(n) = O(n)**

**최악의 경우**

  비교 횟수

    - 외부 루프의 각 단계마다 i번의 비교 수행

    - (n-1) + (n-2) + ... + 2 + 1 = 2n(n-1)/2 = O(n^2)


  교환 횟수

    - 외부 루프의 각 단계마다 i+2번의 이동 발생

    - n(n-1)/2 - 2(n-1) = (n^2+3n-4)/2 = O(n^2)

  **Worst T(n) = O(n^2)** 

----------------

# 버블 정렬

- **서로 인접한** 두 원소를 비교하여 정렬하는 알고리즘
  
- 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환

- (1번째 - 2번째), (2번째 - 3번째), (3번째 - 4번째), ... , (n-1번째 - n번째)

- 1회전을 시행하고 나면 가장 큰 자료가 맨 뒤로 위치하게 된다.
  
  2회전은 마지막 자료를 제외한 자료끼리 시행한다.

  이런 식으로 1회전을 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.


![버블 정렬](https://gmlwjd9405.github.io/images/algorithm-bubble-sort/bubble-sort.png)

## 장단점

**장점**

- 단순하고 구현하기 간단하다.

**단점**

- 가장 큰 요소가 가장 왼쪽에 위치했다면, 가장 오른쪽으로 가기 위해서 배열에서 모든 다른 요소들과 교환돼야 한다.

- 가장 큰 요소가 이미 가장 오른쪽에 있는 경우에도(이미 정렬되어 있음에도), 비교가 일어남

일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다


## 시간 복잡도

비교횟수

- n-1, n-2, …, 2, 1 번 = n(n-1)/2 번


교환 횟수

- 한 번 교환하기 위해 3번의 이동(SWAP 함수의 작업)이 필요하므로, 역순으로 정렬되어 있는 최악의 경우, (비교횟수*3)번 = 3n(n-1)/2번

**T(n) = O(n^2)**

--------

# 병합 정렬

- 안정 정렬, 분할 정복 알고리즘 중 하나.
   
   - 분할 정복이란?
 
     문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략

 - 병합 정렬은 다음의 단계를 거친다.

   - 분할(Divide)
  
   - 정복(Conquer)
  
   - 결합(Combine)
  
## 과정

1. 정렬되지 않은 배열을 절반으로 잘라 비슷한 크기의 두 부분으로 나눈다.

2. 각 부분의 배열을 **재귀적으로** 합병 정렬을 이용해 정렬

3. 두 부분의 리스트를 다시 하나의 정렬된 리스트로 합병

- 각 부분 배열을 정리할 때도 합병 정렬을 순환적으로 호출하여 정렬
  
- 두 개의 정렬된 배열을 하나로 합치기 위해, **임시 배열**을 이용한다.

- *합병 정렬에서 실제로 정렬이 이뤄지는 시점은 2개의 리스트를 합병(merge)하는 단계*

  **<두 개의 정렬된 리스트를 합병하는 과정>**
  
  - 처음부터 하나씩 비교하여 더 작은 값을 새로운 리스트(sorted)로 옮긴다.
    
  - 둘 중에 하나가 끝날 때까지 이 과정을 반복한다.
    
  - 정렬된 새로운 리스트를 원래 리스트로 옮긴다.
 
![병합 정렬](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png)

![병합 정렬 합병 단계](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort.png)

## 장단점

**단점**

- 레코드를 배열로 구성하면 임시 배열이 필요하다

  -> 제자리 정렬 X
  
- 배열의 크기가 큰 경우(레코드 수가 많은 경우), **이동(병합 단계에서 발생)**횟수가 커져 시간 낭비가 많아진다.

  - 두 배열 요소 비교
 
  - 작은 요소를 임시 배열에 복사 -> 이 과정 반복
 
  - 최종적으로 모든 요소를 임시 배열에 복사하면, 다시 원래의 배열로 복사  

**장점**

- 안정적

- 리스트를 **연결 리스트(Linked List)**로 구현하면 링크(포인터)만 수정하면 되므로, 데이터의 이동은 무시할 수 있을 정도로 작아짐

  -> 제자리 정렬 가능
  
- 크기가 큰 레코드를 정렬할 경우, 연결 리스트를 사용하면 합병 정렬은 그 어떤 방법보다 효율적



## 시간 복잡도

### 분할 단계

  비교 연산, 이동 연산 수행 X

### 합병 단계

![합병 단계 시간복잡도](https://gmlwjd9405.github.io/images/algorithm-merge-sort/sort-time-complexity-etc.png)

  (비교횟수)

  - 순환호출 깊이:
  
    n = 2^k 라고 가정한다.
  
    예를 들어, n = 2^3 이면
  
    2^3 -> 2^2 -> 2^1 -> 2^0 이므로
  
    이를 일반화하면
  
    n = 2^k -> **k = log2n**

  - 각 합병 단계의 비교 연산:
 
    크기 1인 배열 2개를 합병하는데 **최대** 2번의 비교 연산 필요 -> n/2쌍 * 2 = n번

    크기 2인 배열 2개를 합병하는데 최대 4번의 비교 연산 필요 -> n/4쌍 * 4 = n번

    ... 이런 과정을 일반화하면 매번 **최대 n번**의 비교 연산 필요

  => 순환 호출의 깊이 * 각 단계마다의 비교 연산 횟수 = **nlog2n**

  (이동횟수)

  - 순환호출 깊이:

    **k = log2n**

  - 각 합병 단계의 이동 연산:

    임시 배열에 복사했다가 다시 원래 배열에 복사해야 하므로 **2n번**

  => 순환 호출의 깊이 * 각 합병 단계의 이동 연산 = **2nlog2n**


*T(n) = nlog₂n(비교) + 2nlog₂n(이동) = 3nlog₂n = **O(nlog₂n)***
     
